/*
 * Copyright (c) 2008-2009 Strasbourg University
 * Copyright (c) 2009 INRIA
 *
 * SPDX-License-Identifier: GPL-2.0-only
 *
 * Author: David Gross <gdavid.devel@gmail.com>
 *         Sebastien Vincent <vincent@clarinet.u-strasbg.fr>
 *         Mohamed Amine Ismail <amine.ismail@sophia.inria.fr>
 */

// Network topology
// //
// //             n0   r    n1
// //             |    _    |
// //             ====|_|====
// //                router
// //
// // - Tracing of queues and packet receptions to file "simple-routing-ping6-udp.tr"
// - UDP flow from n0 to n1 of 1024 byte packets at intervals of 50 ms
// - Ping application from n0 to n1 via router r

#include "ns3/applications-module.h"
#include "ns3/core-module.h"
#include "ns3/csma-module.h"
#include "ns3/internet-apps-module.h"
#include "ns3/internet-module.h"
#include "ns3/ipv6-routing-table-entry.h"
#include "ns3/ipv6-static-routing-helper.h"

#include <fstream>

using namespace ns3;

NS_LOG_COMPONENT_DEFINE("SimpleRoutingPing6UdpExample");

/**
 * @class StackHelper
 * @brief Helper to set or get some IPv6 information about nodes.
 */
class StackHelper
{
  public:
    /**
     * @brief Add an address to a IPv6 node.
     * @param n node
     * @param interface interface index
     * @param address IPv6 address to add
     */
    inline void AddAddress(Ptr<Node>& n, uint32_t interface, Ipv6Address address)
    {
        Ptr<Ipv6> ipv6 = n->GetObject<Ipv6>();
        ipv6->AddAddress(interface, address);
    }

    /**
     * @brief Print the routing table.
     * @param n the node
     */
    inline void PrintRoutingTable(Ptr<Node>& n)
    {
        Ptr<Ipv6StaticRouting> routing = nullptr;
        Ipv6StaticRoutingHelper routingHelper;
        Ptr<Ipv6> ipv6 = n->GetObject<Ipv6>();
        uint32_t nbRoutes = 0;
        Ipv6RoutingTableEntry route;

        routing = routingHelper.GetStaticRouting(ipv6);

        std::cout << "Routing table of " << n << " : " << std::endl;
        std::cout << "Destination\t\t\t\t"
                  << "Gateway\t\t\t\t\t"
                  << "Interface\t"
                  << "Prefix to use" << std::endl;

        nbRoutes = routing->GetNRoutes();
        for (uint32_t i = 0; i < nbRoutes; i++)
        {
            route = routing->GetRoute(i);
            std::cout << route.GetDest() << "\t" << route.GetGateway() << "\t"
                      << route.GetInterface() << "\t" << route.GetPrefixToUse() << "\t"
                      << std::endl;
        }
    }
};

int
main(int argc, char** argv)
{
#if 0
  LogComponentEnable ("Ipv6L3Protocol", LOG_LEVEL_ALL);
  LogComponentEnable ("Icmpv6L4Protocol", LOG_LEVEL_ALL);
  LogComponentEnable ("Ipv6StaticRouting", LOG_LEVEL_ALL);
  LogComponentEnable ("Ipv6Interface", LOG_LEVEL_ALL);
  LogComponentEnable ("Ping", LOG_LEVEL_ALL);
  LogComponentEnable ("UdpClient", LOG_LEVEL_INFO);
  LogComponentEnable ("UdpServer", LOG_LEVEL_INFO);
#endif

    // Command line arguments
    bool enableUdp = true;
    bool logging = true;
    
    CommandLine cmd(__FILE__);
    cmd.AddValue("enableUdp", "Enable UDP client-server applications", enableUdp);
    cmd.AddValue("logging", "Enable logging", logging);
    cmd.Parse(argc, argv);

    if (logging)
    {
        LogComponentEnable("UdpClient", LOG_LEVEL_INFO);
        LogComponentEnable("UdpServer", LOG_LEVEL_INFO);
        LogComponentEnable("Ping", LOG_LEVEL_INFO);
    }

    StackHelper stackHelper;

    NS_LOG_INFO("Create nodes.");
    Ptr<Node> n0 = CreateObject<Node>();
    Ptr<Node> r = CreateObject<Node>();
    Ptr<Node> n1 = CreateObject<Node>();

    NodeContainer net1(n0, r);
    NodeContainer net2(r, n1);
    NodeContainer all(n0, r, n1);

    NS_LOG_INFO("Create IPv6 Internet Stack");
    InternetStackHelper internetv6;
    internetv6.Install(all);

    NS_LOG_INFO("Create channels.");
    CsmaHelper csma;
    csma.SetChannelAttribute("DataRate", DataRateValue(1000000000));
    csma.SetChannelAttribute("Delay", TimeValue(MicroSeconds(500)));
    NetDeviceContainer d1 = csma.Install(net1);
    NetDeviceContainer d2 = csma.Install(net2);

    NS_LOG_INFO("Create networks and assign IPv6 Addresses.");
    Ipv6AddressHelper ipv6;
    ipv6.SetBase(Ipv6Address("2001:1::"), Ipv6Prefix(64));
    Ipv6InterfaceContainer i1 = ipv6.Assign(d1);
    i1.SetForwarding(1, true);
    i1.SetDefaultRouteInAllNodes(1);
    ipv6.SetBase(Ipv6Address("2001:2::"), Ipv6Prefix(64));
    Ipv6InterfaceContainer i2 = ipv6.Assign(d2);
    i2.SetForwarding(0, true);
    i2.SetDefaultRouteInAllNodes(0);

    stackHelper.PrintRoutingTable(n0);

    // Create Ping application to send ICMPv6 echo request from n0 to n1 via r
    NS_LOG_INFO("Create Ping application.");
    uint32_t packetSize = 1024;
    uint32_t maxPacketCount = 100;
    PingHelper ping(i2.GetAddress(1, 1));
    ping.SetAttribute("Count", UintegerValue(maxPacketCount));
    ping.SetAttribute("Size", UintegerValue(packetSize));
    ApplicationContainer pingApps = ping.Install(net1.Get(0));
    pingApps.Start(Seconds(2));
    pingApps.Stop(Seconds(1120));

    // Create UDP applications if enabled
    if (enableUdp)
    {
        NS_LOG_INFO("Create UDP applications.");
        
        // Create UdpServer application on node n1
        uint16_t port = 4000;
        UdpServerHelper server(port);
        ApplicationContainer udpServerApps = server.Install(n1);
        udpServerApps.Start(Seconds(1));
        udpServerApps.Stop(Seconds(1120));

        // Create UdpClient application on node n0 to send to node n1
        uint32_t MaxPacketSize = 63024;
        Time interPacketInterval = Seconds(0.01);
        uint32_t maxPacketCountUdp = 10000;
        UdpClientHelper client(i2.GetAddress(1, 1), port);
        client.SetAttribute("MaxPackets", UintegerValue(maxPacketCountUdp));
        client.SetAttribute("Interval", TimeValue(interPacketInterval));
        client.SetAttribute("PacketSize", UintegerValue(MaxPacketSize));
        ApplicationContainer udpClientApps = client.Install(n0);
        udpClientApps.Start(Seconds(2.1)); // Start slightly after ping to avoid conflicts
        udpClientApps.Stop(Seconds(1120));
    }


    NS_LOG_INFO("Run Simulation.");
    Simulator::Run();
    Simulator::Destroy();
    NS_LOG_INFO("Done.");

    return 0;
}